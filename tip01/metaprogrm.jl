# Julia的元编程入门
##数据即程序
```1+1是表达式，"1+1"是字符串（数据），但字符串里头是表达式，可以通过 Meta.parse把它解析成表达式Expr：```

prog ="1+1"

ex1 = Meta.parse(prog)

typeof(ex1)


``` 你也可以使用前缀表达式来直接构造一个表达式，注意，是前缀。
我们通常使用的都是中缀表达式，也就是二元运算符写在中间，比如1 + 1的“+”写在了中间。
但是这样就需要引入括号，对计算机来说并不友好。
前缀和后缀都可以不需要引入括号来解决优先级问题。```

ex2 = Expr(:call, :+, 1,1)
# to test
ex1 == ex2

# Julia其实把它们表示成了语言本身可以访问的数据结构。
#由标头（表明表达式类型的符号）和表达式参数构成：
ex1.head

ex1.args




#可以使用dump获得带缩进的描述：
dump(ex2)

# 你可能好奇:是什么？它声明的是一个符号（Symbol），比如：你可以用来表示代数运算中的x、 y、 z。
:foo
typeof(ans)
:foo == Symbol("foo")


```
Symbol的实现机制是string interning（不太好翻译，intern是实习的意思，和这里无关，
但是作为及物动词可以理解为拘留，但是“字符串拘留”显然有点怪怪的）。

这个概念源自于Lisp，因为字符串是不可变的。如果你修改了字符串，
其实是创建了一块新的内存。string interning就是利用字符串不可改变这一点。
如果字符串不可更改，作为常量保存在一个地方，
比如常量池，那么新建的字符串如果内容和之前的字符串一样，那么就可以直接引用到同一块内存，而不需要再分配一块新的内存。

不过节约内存的理由，还是不够有说服力。
使用string interning的一个很重要的理由是可以加速字符串的比较。
字符串的比较一直都是编译器和动态语言的瓶颈，
那么使用了string interning，只需要比较一个指针地址是否一样就行了
，不需要逐个比对字符。
```

a = [:apple, :pineapple]
b = [:apple, :pineapple]

a[1] == b[1]

# 表达式和值的计算
## Quote（引用）
````:的第二语法目的是quote（引用）， :后面是一个括号，括号里面是可以直接写Julia的表达式。```
ex = :(a + b * c + 1)

:(a + b * c + 1)

typeof(ex)


ex = quote
    x = 1
    y =2
    x+y
end
